# HTTP의 진화와 버전별 특징

## HTTP/0.9

### 원라인 프로토콜

- 버전 넘버도 없었고, 오직 HTML 전송을 위해서만 사용되던 시절

### **HTTP 헤더 및 상태 코드 없음**

- HTML 파일만 전송 가능했기 때문
- 별도 헤더를 통해 부가 정보를 전달할 필요 없었음 (HTML에 모든 정보 포함)
- 오류가 난 경우에도 상태 코드 대신 오류에 대한 설명을 담은 HTML만 내려주면 끝

### **GET 메서드만 사용 가능**

- 어차피 문서를 가져오는 것만이 목적이었기 때문

## HTTP/1.0

### 더 유연한 프로토콜

- 상당히 제한적이었던 0.9를 개선해 더 다양한 형식의 데이터를 주고받고자 함

### HTTP 헤더, 상태 코드 추가

- Content-Type 헤더의 등장으로 HTML 이외의 다른 문서들 전달 가능하게 됨
- 이외에도 다양한 헤더 도입으로 메타데이터 전송이 가능해져 더 유연한 프로토콜이 됨
- 상태 코드를 통해 요청 결과의 성공/실패를 알고 적절한 대처를 할 수 있게 됨

## HTTP/1.1

### 첫 표준 프로토콜

- 1997년 초(HTTP/1.0 발표 몇 달 후) 발표됨
- 이전 버전의 모호함을 명확하게 하는 표준화 작업이 많이 반영됨

### Keep-Alive 도입을 통한 연결 재사용

- TCP 커넥션을 위한 3-way handshaking 소요 시간을 줄이기 위함
- 아래 2개의 value를 가질 수 있음
    - timeout: idle time 기준 얼마나 유지?
    - max: 하나의 커넥션 내에서 최대 몇 개의 요청을 허용?

### 파이프라이닝 기법 도입

- 첫 번째 요청에 대한 응답이 도착하기 전 두 번째, 세 번째 요청을 전송할 수 있도록 하여 요청 후 응답을 기다리는 과정에서 생기는 통신 지연 시간을 단축
- 하지만 아래와 같은 문제점이 존재
    - Head of Line Blocking - 동일 연결에 대한 후속 요청은 요청이 완료될 때까지 지연되는데, 첫 요청이 패킷 손실 등의 이유로 차단되면 이후의 모든 후속 요청이 함께 차단되어버림
    - 구현의 어려움 - 응답이 순차적으로 도착해야 함을 보장해야 함. 대부분의 프록시 서버에서 이를 제대로 구현하지 못했음

## HTTP/2

### HTTP/1.1의 성능 개선

- HTTP/1.1은 매우 완성도가 높은 표준으로, 아주 오랜 시간 동안 개선만 이루어지며 안정적으로 표준 자리를 지킴
- HTTP/2.0도 기존 버전을 대체하는 것이 아니라 확장함으로서 성능을 개선

### 바이너리 프레이밍

- 기존 텍스트 형식이었던 HTTP 메서드를 바이너리 형태로 캡슐화
- 메시지의 크기를 더 작게 만들어 더 효율적으로 전송할 수 있게 됨

### 서버 푸시

- 별도 polling과 같은 기법 없이도 서버가 새 리소스를 클라이언트에게 전송할 수 있도록 하는 기법

### 스트림을 통한 병렬화

- 각 스트림은 서로 영향을 미치지 않으며, 응답 순서 보장이 필요 없으므로 Head of Line Blocking 문제가 해결됨
- 스트림 간 우선순위 설정이 가능하여 리소스 간 전송 우선 순위 설정이 가능

## HTTP 3

### 새로운 프로토콜 채택

- 이전 버전까지는 TCP 기반의 프로토콜이었음
- 3버전부터는 QUIC라는 UDP 기반 프로토콜을 사용

### UDP 기반 스트림을 통한 병렬화

- HTTP/2 까지는 별도 스트림을 이용할지라도 TCP 연결 기반으로 동작하기 때문에 패킷 손실 감지, 재전송 등의 처리에 의해 전체 스트림이 차단될 수 있었음
    - 즉, 스트림 간 완전한 독립을 이루었다고 보기 어려움
- 그러나 HTTP/3에서는 UDP 기반의 프로토콜(QUIC)을 기반으로 스트림을 실행하기 때문에 완전한 독립이 가능해짐
    - 어떻게? QUIC은 스트림 독립적 패킷 손실 감지, 재전송 처리 로직을 구현
        - UDP 기반이라고 해서 신뢰성을 버리겠다는 것이 아님. **TCP보다 더 효율적으로 신뢰성 보장 알고리즘을 구축하겠다는 것일 뿐**
