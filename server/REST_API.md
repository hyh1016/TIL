# REST API

## **`RE`presentational `S`tate `T`ransfer**

### **정의**

* **분산 하이퍼미디어 시스템(ex: 웹)을 위한 소프트웨어 프로그램 아키텍처의 한 형식**
  * **하이퍼텍스트**: 일반 문서처럼 문서인데 문서에서 다른 문서로 링크를 통해 이동할 수 있는 문서
  * **하이퍼미디어**: 하이퍼텍스트 중에 단지 문서만 연결되지 않고 각종 그림이나 소리, 동화상이 한꺼번에 연결된 개념을 가리키는 말로 하이퍼텍스트와 멀티미디어의 결합

### **등장 배경**

* **클라이언트의 다양화 (기존의 웹 클라이언트 뿐 아닌 모바일, 사물인터넷 등 등장)**
  * 클라이언트마다 서로 다른 서버를 만드는 것은 비효율적
  * 범용적으로 사용할 수 있는 아키텍처를 적용한 서버가 필요해짐
* **클라이언트의 편의성을 위함**
  * 여러 서버 개발자가 하나의 서비스의 API를 나누어 개발 ⇒ 서로 다른 코딩 스타일에 의해 클라이언트가 의미를 이해하기 어려워짐
  * 준수해야 할 공통 규약을 만들어 문제를 해결하고자 함

### **REST의 구성**

* **자원(RESOURCE) - URI**
  * 모든 자원은 `URI`에 의해 고유하게 구별될 수 있어야 한다.
* **행위(Verb) - HTTP Method**
  * HTTP 프로토콜의 `GET`, `POST`, `PUT`, `DELETE`와 같은 메서드를 통해 행위를 나타낸다.
* **표현(Representations)**
  * 자원은 특정 데이터 포맷으로 표현되고 전달된다.
  * 현재에는 주로 `JSON`을 이용한다.

### **REST의 특징**

* **Uniform (유니폼 인터페이스)**
  * URI로 지정한 리소스의 조작을 통일되고 한정적인 인터페이스로 수행
  * 특정 언어나 기술에 종속되지 않도록 하는 것이 목표
* **Stateless (무상태성)**
  * 요청을 처리하기 위해 특정 정보를 저장하지 않으며 단순히 들어온 요청을 처리하기 위해 요청 내부에 존재하는 정보만을 이용
  * 여러 가지 장점이 존재
    * 서버 구현이 단순해짐
    * 서버 확장성에 좋음
* **Cacheable (캐시 가능)**
  * REST는 HTTP 웹 표준을 그대로 사용하기 때문에 HTTP가 가진 캐싱 기능 적용 가능 (Last-Modified, E-Tag)
  * 대용량 데이터 처리에 유리
* **Self-descriptiveness (자체 표현 구조)**
  * 메시지만 보고도 의미를 쉽게 이해 할 수 있는 자체 표현 구조를 사용
  * `POST` /data 라는 API를 보면 데이터를 생성하는 API임을 쉽게 알 수 있다.
* **Client - Server Structure (클라이언트-서버 구조)**
  * 클라이언트와 서버의 역할을 확실히 구분
    * 클라이언트 - 사용자 인증, 컨텍스트(세션, 로그인 정보)등 관리
    * 서버 - (허용된) 클라이언트가 데이터를 편안하게 접근, 제어할 수 있도록 API 제공
* **Layered System (계층형 시스템)**
  * REST 서버는 여러 개의 계층으로 구성될 수 있음
  * `보안`, `로드 밸런싱`, `암호화`, `PROXY`, `게이트웨이` 등의 계층으로 분리

## **REST API Design Guide**

### **자원과 행위**

* URI는 정보의 `리소스(Resource)`를 표현해야 한다. (행위가 들어가서는 안 된다!)
* 자원에 대한 행위는 HTTP Method (GET, POST, PUT, DELETE 등)으로 표현한다.
  * GET: 리소스를 조회
  * POST: 자원을 생성
  * PUT: 리소스 수정
  * DELETE: 리소스 삭제

### **URI 설계 시 주의할 점**

* 슬래시 구분자(/)는 계층 관계를 나타내는 데 사용한다.
* URI 마지막 문자로 슬래시(/)를 포함하지 않는다.
* 언더바(\_)는 사용하지 않고, 단어 구분을 위해서는 하이픈(-)을 사용한다.
* 대문자는 사용하지 않는다.
*   파일 확장자는 url에 포함시키지 않고, 이 정보가 필요하다면 `Accept` 헤더를 이용한다.

    ```
    Accept: image/jpg
    ```
* 리소스 간에는 연관 관계가 있을 수 있다. 이는 슬래시 구분자를 통해 나타낸다.
  * ex) 학생이 수강하는 과목: `/students/{studentId}/course`
* 자원은 Collection-Document 관계로 나타낸다.
  * 이 때 Collection은 복수, Document는 단수로 나타낸다.
  * ex) User 컬렉션의 userId 도큐먼트: `/users/{userId}`
