# @Async

## Spring에서 비동기 처리를 구현하는 방법

- Application 클래스 또는 관련 Configuration 클래스에 `@EnableAsync` 어노테이션을 추가
- 별도 스레드에서 비동기로 실행하고자 하는 메서드에 `@Async` 어노테이션을 추가

## 동작 원리

- proxy를 이용
- 즉, @Async가 달린 메서드는 프록시 객체를 통해 `사용할 스레드 선정 및 작업 할당`이라는 `횡단 관심사 로직`이 수행된 후에 호출됨
- 따라서, `접근 제어자가 public`이어야 하며 `self-invocation`이 불가능

## 반환 타입

### void

- 메서드의 반환 결과가 어딘가에서 쓰이지 않을 때에는 아무것도 반환하지 않도록 처리하면 됨

### **Future, CompletableFuture**

- 반환 결과를 통해 추가적인 처리가 이루어져야 하는 경우 위의 2가지를 반환할 수 있음
- 더 세밀한 컨트롤을 원하고, Java 8 이상의 버전을 쓴다면 후자 쪽이 좀 더 나은 선택이라 볼 수 있음

## Executor

- 기본값으로 설정하면 `SimpleAsyncTaskExecutor`를 사용
    - 비동기 로직이 호출될 때마다 새로운 스레드를 생성하는 Executor
- 매번 새로운 스레드를 생성하는 것은 다음과 같은 문제를 가짐
    - 너무 많은 스레드가 생성될 수 있음 - 100만 개 요청이 오면 100만 개 스레드를 만드는데?
    - 매번 스레드를 새로 만드는 것은 스레드 생성 비용을 과도하게 지불하는 일
- 따라서, 커스텀 `ThreadPoolTaskExecutor`를 만들어 적절한 개수의 스레드 풀을 이용할 것을 권장
    - 나는 이 커스텀 Executor를 `AsyncConfig`에 모아두고, 해당 Config에 `@EnableAsync`를 붙여놓는 방식을 사용 중

## 예외 처리

- 당연한 말이지만, 비동기 로직은 호출 시점부터 별도 스레드로 분리되므로 `예외가 호출자에게 전파되지 않음`
- 반환값을 콜백으로 전달받는 메서드에서는 예외처리가 어렵지 않지만, 반환값이 void인 경우`AsyncUncaughtExceptionHandler`를 구현하는 클래스에서 별도의 예외 핸들링을 해 줘야 함
