# JPA N+1 Problem

## OneToMany(일대다) 데이터 조회로 보는 N+1

사용자, 게시물 엔티티가 존재한다고 하자. 하나의 사용자는 여러 게시물을 작성할 수 있으므로 사용자-게시물은 일대다 관계를 갖는다.

여기서 모든 게시물을 조회하고, 게시물을 작성한 사용자의 이름도 함께 조회하는 비즈니스 로직을 작성한다고 하자.

```jsx
List<Post> postList = postRepository.findAll();

for (Post post: postList) {
		System.out.println("포스트명: " + post.getName());
		System.out.println("작성자: " + post.getUser().getName());
		System.out.println("내용: " + post.getContent());
}
```

이 로직을 실행한 후 실행된 쿼리들을 보면, 아래와 같은 쿼리들이 실행되었음을 알 수 있다.

```jsx
모든 포스트 조회
포스트1의 사용자 조회
포스트2의 사용자 조회
...
포스트N의 사용자 조회
```

즉, 1번의 쿼리가 실행될 것을 예상하고 작성한 로직임에도 N개 포스트의 조회에 대해 N+1번의 쿼리가 실행되었음을 알 수 있다.

## N+1 Problem

* N개의 데이터를 조회하기 위해 1번의 쿼리만 실행될 것을 기대했으나 \*\*`N번의 쿼리가 추가적으로 발생`\*\*하는 문제를 말함
* JPA는 쿼리를 자동으로 생성해주는 프레임워크인 만큼 잘 모르고 쓰면 심각한 비효율성을 초래할 수 있고, N+1 문제는 이 대표적 사례

## 왜 발생하는가?

* JPA는 기본적으로 조회 시 연관 관계에 있는 엔티티들을 join을 통해 가져오는 대신 추가적 조회 쿼리를 실행해 가져올지 말지 결정함
  * 한 번에 다 가져오는 것은 메모리 낭비이기도 하고, DB와 달리 객체는 참조라는 것을 가져 언제든 연관된 엔티티가 무엇인지에 대해 알 수 있기 때문에 조회 시점을 미뤄도 상관 없기 때문인 듯
* 따라서 연관 엔티티가 조인 대신 별도 조회로 획득되기 때문에 여러 번의 쿼리가 발생하는 것

## 어떻게 해결하는가?

### 1. fetch join을 통한 해결

* JPQL에서 fetch join을 명시해주는 방법
* 기본 join을 이용해도 엔티티를 가져올 수는 있지만, 영속성 컨텍스트에 등록되는 것은 조회한 엔티티 뿐임
* fetch join임을 명시해주면 join을 통해 데이터를 가져와 조회한 엔티티와 연관 엔티티(join한 엔티티) 모두 영속성 컨텍스트에 등록
* 하지만 fetch join에는 치명적 문제점이 있는데, `데이터를 일부만 조회해오는 것이 불가`하다는 것
  * 즉, SQL의 `limit` 기능을 적용할 수 없다는 것
  * 10만 개 데이터가 있으면 모두 조회해오므로 메모리에 치명적

### 2. @BatchSize를 통한 N+1 해결

* 여러 번의 쿼리를 in 절을 통해 하나로 묶어 실행하도록 하는 방법
* 해결이라기보다는 우회 (결국 여러 번의 쿼리가 발생할 위험은 있으나, 그 수를 batch size가 M이라고 했을 때 N/M개 만큼 줄이는 것)
* fetch join과 마찬가지로 데이터를 일부만 조회해오지 못하는 문제 존재

### 3. @EntityGraph, @NamedEntityGraph

* 쿼리 메소드에 함께 조회할 연관 엔티티를 명시하는 방법
* 페이징이(데이터 일부 적재가) 가능하고, join을 통해 쿼리를 1개로 줄일 수 있다는 점에서 앞선 해결책들보다는 문제가 적어 보임
* 그러나 `left outer join`을 이용하기 때문에 `카티시안 곱`에 의해 하나의 엔티티가 여러 번 조회되는 현상이 발생할 수 있음
  * 이건 fetch join 또한 마찬가지

## 현재 사용하는 방법

결국 위의 1, 2, 3번 해결책 모두 나름의 문제점을 가지고 있기 때문에 사용에 어려움이 있었고, 현재에는 `QueryDSL`을 이용하여 해당 문제를 해결하고 있다.

JPQL 레벨에서 이 문제를 깔끔하게 해결하려면 쿼리가 복잡해지고, 복잡한 문자열 쿼리가 여러 개 생기면 변경과 확장이 어려워져 유지보수에 용이하지 않은 코드가 되기 때문이다.

## 출처

[https://bcp0109.tistory.com/304](https://bcp0109.tistory.com/304)

[https://cobbybb.tistory.com/18](https://cobbybb.tistory.com/18)
