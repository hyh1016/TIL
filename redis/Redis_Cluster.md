# Redis Cluster

## Redis의 고가용성(HA)과 확장성

- 한 대의 Redis 서버만 사용하게 되면(Standalone) 이 서버가 죽었을 때 레디스를 사용할 수 없게 됨 (고가용성 필요)
- 또한 Redis는 In-Memory DB인 만큼 데이터 증가에 의한 Scale-Up이 비용적인 측면에서 RDB보다 더 빠르게 한계가 찾아옴 (확장성 필요)
- **고가용성이 필요하다면 [Sentinel](./Redis_Sentinel.md)을 도입할 수 있음**
- **고가용성과 확장성이 모두 필요하다면 Cluster를 도입할 수 있음**

## Redis Cluster

https://redis.io/docs/latest/operate/oss_and_stack/management/scaling/

### 동작 방식

- 데이터를 여러 노드에 분산(Sharding)하여 저장하고, 쿼리를 적절 노드로 라우팅

### 왜 쓰는가?

- 확장성: 데이터를 여러 노드에 분산 저장하여 단일 노드의 메모리 Scale-Up 한계를 극복
- 고가용성: 일부 노드에 장애가 발생해도 요청 처리 가능
    - 과반수 이상의 마스터 노드가 사용이 불가능하면 요청 처리가 불가능해질 수 있음

### 구성 요소

- 클러스터는 다수 개의 레디스 클러스터 노드로 구성되며, 각각은 마스터 노드 또는 레플리카 노드
- 각 노드는 2개 포트에 대해 TCP 연결을 수신해야 함
    - 6379: 서비스 포트 (클라이언트 응답용)
    - 16379: 클러스터 버스 포트 (내부 통신용)
- 최소 3개의 마스터 노드, 3개의 레플리카 노드를 권장함

### 샤딩 방식

- 클러스터는 모든 키가 해시 슬롯의 일부가 되는 형태의 샤딩을 사용하며, 해시 슬롯의 개수는 16384개임
- CRC16(key) % 16384 = 해당 데이터를 저장할 해시 슬롯
- 각 노드에 해시 슬롯을 범위 할당하여 데이터를 분산 저장시킴
- 노드를 추가/제거할 때에는 기존 범위를 조정하여 적절히 분산하면 됨

### NAT/Docker 환경의 클러스터 연결 문제

- 레디스 클라이언트는 클러스터 모드로 레디스 클러스터에 연결할 때 각 노드가 알려주는 IP를 받아 연결을 시도하게 됨
- 이때 NAT/Docker 환경에 있는 노드들이 알려주는 주소는 클라이언트에서 그대로 접근할 수 없는 주소인 경우가 많음 (private IP)
- 포트도 마찬가지로 외부 포트를 내부 포트로 연결해도 레디스 노드가 announce하는 포트가 내부 포트라면 정상 연결이 안 됨
- 이와 같이 노드 입장에서 announce하는 IP, 포트 정보가 실제로 외부(클라이언트)에서 유효한 것이 아닌 경우가 많아 NAT/Docker 환경에서는 클러스터 연결이 되지 않을 수 있음
- 어떻게 해결해야 할까?
    1. 각 노드가 공인 IP를 알리도록 `redis.conf`를 수정하거나 (노드 레벨에서의 조치)
    2. 클라이언트 측에서 레디스가 알리는 IP를 자신이 접근할 수 있는 다른 IP로 우회하도록 설정
    3. 가장 좋은 방법은, 클라이언트 또한 해당 내부망에 속해있는 것 (그러면 문제가 되지 않음)

### 왜 최소 3개의 마스터와 3개의 레플리카 노드를 권장할까?

- **최소 권장 마스터가 3개인 이유: 과반수 합의**
    - 마스터끼리의 헬스 체크 과정에서 하나의 마스터가 응답하지 않을 때 다른 마스터들이 이 마스터가 죽었다고 판단할지 말지 결정하기 위해, 과반수 합의를 할 수 있어야 함
    - 하나가 죽었을 때 과반수 합의가 가능한 최소 개수가 바로 3개 (3개 중 2개의 동의 == 과반수)
        - 2개면 2개 중 1개의 동의(50%)는 과반수가 아님
    - 과반수일 때 조치하는 이유는 **Split Brain** 방지를 위함
- **최소 권장 레플리카 3개인 이유(마스터 당 1개씩):**
    - 하나가 죽어도 나머지를 통해 잘 처리하기 위함 (보통 2개가 동시에 죽는 일은 잘 없으므로)

### 왜 해시 슬롯의 개수는 16384개일까?

- https://github.com/redis/redis/issues/2576
- 왜 16384 일까? (참고로 16384는 2^14)
- 클러스터 내 각 노드들은 Gossip(가십) 프로토콜을 통해 상태 정보를 주고받는데, 이때 담당하는 해시 슬롯을 비트맵 형태로 주고받음
- 16384개 슬롯을 비트맵으로 나타내면 16384/8 = 2048 (2KB) 이므로 2KB 크기만큼의 데이터를 주고받게 되는 것
- 이게 적절한 수치라고 생각했기 때문에 16384가 되었다고 함
