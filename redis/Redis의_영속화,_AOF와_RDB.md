# Redis의 영속화, AOF와 RDB

## 왜 필요한가?

- Redis는 인메모리 데이터베이스이기 때문에, Down 시 데이터가 휘발됨
- 휘발되면 안 되는 데이터를 저장하는 경우 이는 치명적이므로, 데이터를 디스크에 저장하는 메커니즘을 제공

## RDB (Redis Database)

정해진 간격마다 메모리를 바이너리 형태의 스냅샷(dump.rdb)으로 저장하는 방식

### 장점

- 바이너리 파일이기 때문에 스냅샷 파일 크기가 작음
- 단순히 해당 데이터를 복구하기만 하면 되므로 복구 속도가 빠름

### 단점

- 스냅샷 이후 시점의 데이터는 유실됨. 데이터 손실이 치명적이라면 RDB만 사용하는 것은 위험
- fork() 사용 시 메모리 사용량이 순간적으로 늘어날 수 있음
- 데이터셋이 큰 경우 디스크 쓰기가 지연될 수 있음

### 동작 방식

1. `redis.conf`에 `save N M` 형태의 설정을 명시
    - N초 동안 최소 M개 데이터가 변경되면 스냅샷을 생성
    - 기본 값은 `save 60 1000` (60초에 1000개 데이터가 변경되면 동작)
2. 동작 조건을 만족하면 메인 프로세스가 `fork()` 시스템 콜을 호출해 자식 프로세스를 생성
3. 자식 프로세스에서 데이터를 디스크에 쓰고 완료되면 old 스냅샷을 new로 교체
    - 자식 프로세스 생성 시점에 부모 프로세스의 메모리를 복사하고, 부모 프로세스에서 일어나는 데이터 변경은 부모 프로세스에만 반영됨 (Copy-on-Write)

### CoW (Copy-on-Write)

- fork()를 호출하여 자식 프로세스가 생성될 때, 일단 메모리를 통째로 복사하는 것이 아니라 메모리에 대한 참조 정도만 복사하여 부모와 자식은 동일한 메모리 페이지를 공유하게 됨
- 읽기 요청만 처리할 때에는 이 상태를 유지하다가, **부모 또는 자식 프로세스에 쓰기가 발생하면 OS가 공유 페이지에 쓰는 대신 해당 페이지를 똑같이 복사한 새로운 메모리 페이지를 만듦**
- 쓰기가 발생한 프로세스의 페이지에만 쓰고, 다른 페이지에는 쓰기 내용이 반영되지 않게 됨 (Redis에서는 자식은 디스크 영속화를 위한 읽기 전용이므로 부모에만 쓰기가 반영됨)
- 자식 프로세스는 쓰기 발생 이전의 메모리 상태를 기반으로 스냅샷을 만들 수 있게 됨
- 단, CoW 발동 시점에 메모리 사용량이 최대 2배까지 증가하게 되므로 OOM에 주의해야 함

## AOF

데이터 변경 명령을 실행할 때마다 로그 파일에 이 명령들을 순차 기록하는 방식

### 장점

- 데이터 유실을 최소화
- RDB 스냅샷은 바이너리 파일이라 사람이 읽을 수 없는데, AOF 파일은 텍스트 기반이어서 직접 읽고 이해할 수 있음. 변경해서 원하는 명령들만 실행할 수도 있음
    - 실수로 FLUSHALL 명령어를 실행해버렸어도 AOF 파일에서 이 명령어만 사람이 직접 삭제한 뒤 실행하여 데이터 복구를 할 수가 있음

### 단점

- RDB 스냅샷에 비해 파일 크기가 훨씬 큼
- 로그 내 명령을 하나씩 재실행해야 하므로 RDB에 비해 복구 시간이 오래 걸림

### 동작 방식

1. `SET`, `INCR`과 같이 데이터를 변경하는 모든 명령을 로그 파일에 기록
    - 기존 데이터(로그)를 수정하거나 검색하지 않고 데이터를 추가하기만 하는 방식을 Append-only 라고 함
    - 이 방식은 쓰기 속도가 매우 빠름
2. Redis가 Down되었다가 재시작되면 파일에 기록된 명령들을 순차 실행해 데이터를 복구
3. AOF 파일이 너무 커지는 것을 방지하기 위해 주기적으로 재작성(Rewrite)을 수행해 명령 셋을 압축
    - Rewrite는 백그라운드 프로세스로 처리됨

### `fsync`

- 즉시 디스크에 쓰기를 명령하는 시스템 콜
- AOF에서는 아래 3가지 fsync 정책을 지원
    1. appendfsync always: 모든 쓰기 명령 실행 시 fsync 호출
        - 가장 안전함. 이론적으로 데이터 손실이 0
        - 대신 매 쓰기 마다 Disk I/O가 발생하므로 Redis의 쓰기 속도가 매우 느려짐
        - 메인 스레드에서 Disk I/O 완료까지 동기 실행하기 때문에 Redis 쓰기 속도가 Disk I/O 속도의 영향을 받게 됨
    2. appendfsync everysec (default): 1초에 한 번씩 fsync 호출
        - 최대 1초 간 데이터가 유실될 수 있음
        - 성능과 안정성 사이의 타협점
        - 백그라운드 스레드에서 수행 (메인 스레드는 Memory -> OS buffer 까지만 하고 buffer -> Disk 는 백그라운드가)
    3. appendfsync no: Disk 쓰기를 OS에게 위임 (언제 쓸지 모름)
        - fsync로 인한 지연이 없어 가장 빠르지만, 가장 큰 데이터 손실 위험을 가짐

## 무엇을 사용해야 할까?

- 기본적으로는 RDB만 활성화되며 몇 분 정도의 데이터 손실을 감수할 수 있다면 RDB만으로도 충분
- 데이터 손실을 최소화하고 싶다면 AOF '도' 사용
- AOF만 단독으로 사용하는 것은 권장하지 않음
    - for doing database backups, for faster restarts, and in the event of bugs in the AOF engine
    - AOF 파일 자체가 손상될 수도 있고, RDB는 더 빠른 복구를 가능하게 하므로
- 기본적으로 RDB 파일과 AOF 파일이 모두 있을 때에는 AOF 파일 기반 복구를 더 우선적으로 수행함 (더 정확한 데이터일 것이라 추측하므로)

## 혼합(Hybrid) 방식

- 하이브리드 방식이란? AOF Rewrite 시점에 기존 데이터는 RDB 형식으로 파일 앞부분에 저장하고, 새 변경은 다시 AOF 형식으로 append하는 방식
- RDB의 빠른 복구, AOF의 데이터 손실 최소화 2가지 이점을 모두 누릴 수 있는 방식
- `aof-use-rdb-preamble yes` 옵션을 활성화하면 하이브리드 방식으로 동작
