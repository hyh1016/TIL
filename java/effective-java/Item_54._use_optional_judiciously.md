# Item 55. 옵셔널 반환은 신중히 하라

## 메서드가 값을 반환할 수 없는 경우의 대응

### Java 8 이전

- null을 반환
- 예외를 발생

### Java 8 이전 - null을 반환

- Item 54에서 언급했듯 클라이언트에서 null에 대한 처리 코드를 빼먹는 경우 발생하는 `NullPointerException` 문제나 가독성 저하 이슈가 존재

### Java 8 이전 - 예외를 던짐

- 실제 예외 상황이 아님에도 예외를 던지게 됨
    - 예외는 진짜 예외적인 상황에서만 사용하는 것이 좋음
- 예외를 생성하는 비용도 무시할 수 없음
    - **해당 시점의 Stack Trace(스택 추적) 전체를 캡처해야 하기 때문에 예외 생성 비용은 만만치 않음**

### Java 8에서 등장한 Optional<T>

- T타입 객체를 소유하거나 소유하지 않을 수 있는 객체
- 보통 T를 반환해야 하지만 특정 조건에서는 아무것도 반환하지 않는 경우 Optional을 반환하는 것이 좋음
    - `Optional.empty()`를 통해 빈 Optional 객체를 반환할 수 있음
- 반환 타입을 Optional로 명시함으로써, 클라이언트에게 `반환되는 값이 없을 수도 있음을 명시`할 수 있음
    - 클라이언트는 값을 사용하기 위해 반드시 값의 존재 여부를 체크하게 됨
- **Optional을 반환하는 메서드에서는 절대 null을 반환하면 안 됨**
    - Optional 자체를 참조할 때 NullPointerException이 발생하게 되므로, 이는 `Optional의 취지에 반하는` 행위

### Optional을 반환해야 할 때

- 결과값이 없을 수 있으며, 클라이언트가 이에 대한 처리를 해야 할 때

### Optional을 반환하지 않아야 할 때

- 컬렉션, 스트림, 배열, 같은 옵셔널 타입의 결과값이 없을 수도 있는 객체를 반환할 때
    - 컬렉션/스트림/배열은 옵셔널을 사용하는 대신 빈 컬렉션/스트림/배열을 반환
    - 옵셔널은 그 자체로 옵셔널이므로 그대로 반환
- 박싱된 주요 primitive type(int, long, double)을 반환할 때
    - 박싱+옵셔널은 값을 두 번 감싸는 것이 되므로 primitive type을 그냥 사용할 때보다 훨씬 무거워짐
    - 대신 OptionalInt, OptionalLong, OptionalDouble을 사용해 한 번만 감쌀 수 있음
- Map의 value로 사용
    - Map의 value의 존재 여부는 key의 존재 여부로 판단할 수 있도록 구현해야 함
        - map.contains(key)를 통해 존재 여부 판별
    - 만약 value로 Optional을 사용하게 된다면 존재 여부를 판별하는 방식이 2가지로 나뉘게 되므로 데이터를 다루기 더 복잡해짐
- 옵셔널은 사용하는 것이 그렇지 않는 것보다 무겁다는 점에 유의하여, 적재적소에 잘 활용해야 함
