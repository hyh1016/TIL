# Item 80. 스레드보다는 실행자, 태스크, 스트림을 애용하라

## 직접 스레드를 다룰 경우의 단점

### 안전 실패 / 응답 불가 고려

- Item 49의 작업 큐 코드 참조
- 비동기 처리를 위해 작업을 백그라운드 스레드로 직접 위임함에 따라 수행하는 작업이 실패했을 때, 응답할 수 없을 때 등 예외 상황에 대한 처리를 직접 작성해줘야 함 (코드 복잡도 증가)

## 실행자 프레임워크 (Executor Framework)

- `java.util.concurrent` 패키지에 포함된 태스크 실행 기능 모음
- 스레드를 직접 다루는 경우 (위에서 기술했듯) 작업을 비동기로 분리하는 것(작업 단위), 작업을 어떻게 수행 및 제어할지(수행 메커니즘)를 모두 Thread를 통해 결정
    - 역할이 적절히 분리되었다고 볼 수 없음
- 실행자 프레임워크를 사용하면 작업 단위와 실행 메커니즘을 적절하게 분리할 수 있음

### 기본 사용법

```java
ExecutorService executorService = Executors.newSingleThreadExecutor();

Runnable runnable = () -> {
    log.info("execute my work!");
};
executorService.execute(runnable);
```

- 실행자 서비스는 `스레드 풀 제공자`와 같은 역할을 수행
- 스레드 개수, 최대/최소 정책 등을 해당 객체에서 관리 가능
- `Executors`는 정적 팩토리 역할을 하며, 이를 통해 다양한 정책의 스레드 풀을 생성할 수 있음
    - `newCachedThreadPool`
        - 일반적으로 가장 간단하고 빠른 스레드 풀
        - 태스크 요청이 생기면 즉시 스레드에 위임
            - 가용 스레드가 없으면 새 스레드를 생성해 위임
        - 사용자가 아주 많은 서비스에서는 너무 많은 스레드가 생겨 장애가 발생할 수 있기 때문에 권장되지 않음
    - `newFixedThreadPool`
        - 무거운(사용자가 많은) 서버에서 사용하기 좋은 스레드 풀
        - 스레드 개수를 고정해 사용
        - 요청은 큐에 저장되며, 가용 스레드가 생겼을 때 위임됨
- 실행자 프레임워크에서는 작업 단위가 인자로 넘겨지는 Runnable, Callable 등의 구현체이며, 실행 메커니즘이 실행자 서비스
    - 작업 단위는 어떤 작업을 수행할지를 결정
    - 실행 메커니즘은 이 작업들을 어떤 정책을 기반으로 수행할지를 결정
- 실행 메커니즘을 관리할 책임을 실행자 서비스에게 넘김으로써, 실행 메커니즘을 변경하기 더 간편해짐

### 커스터마이징이 필요할 때

- 필요에 따라, 정적 팩토리에서 제공하는 스레드 풀 이상의 `통제권`이 필요할 수 있음
- 이 경우 `ThreadPoolExecutor`를 직접 사용하는 편이 좋음
