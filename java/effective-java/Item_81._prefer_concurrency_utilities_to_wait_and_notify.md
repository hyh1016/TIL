# Item 81. wait와 notify보다는 동시성 유틸리티를 애용하라

## 고수준 동시성 유틸리티

1. 실행자 프레임워크 (Item 80)
2. 동시성 컬렉션
3. 동기화 장치

## 동시성 컬렉션

- 표준 컬렉션 인터페이스에 내부적 동기화를 추가해 구현한 고성능 컬렉션
- 내부적으로 동기화를 수행하고 있기 때문에 `동시성 컬렉션에서 동시성을 무력화하는 것은 불가능`
- 또한, 외부에서 락을 사용하면 성능 저하가 있을 수 있으므로 직접 동시성을 추가하지 않는 것이 좋음
- 동시성을 무력화하지 못하므로 둘 이상의 동작을 동시에 수행함을 보장하려면 `여러 메서드를 원자적 동작으로 묶는 별도 메서드`를 이용해야 함
    - ex) putIfAbsent(없으면 새 값 넣고 null 반환, 있으면 있는 값 반환)
- 동시성 컬렉션의 등장으로 기존 Collections에서 제공하던 동기화 컬렉션은 더이상 사용하지 않음
    - 동시성 프레임워크의 성능이 훨씬 뛰어남

### BlockingQueue

- 동시성 컬렉션의 일종
- producer-consumer 구조의 task queue로 쓰기 용이함
- task 메서드를 호출하면 원소가 있다면 꺼내고 없다면 새 원소가 추가될 때까지 기다린 후 꺼냄
- 대부분의 실행자 서비스에서도 내부적으로 이 컬렉션을 이용

## 동기화 장치

- 스레드가 다른 스레드를 기다릴 수 있도록 하는 장치
- 대표적으로 `CountDownLatch`, `Semaphore`가 존재

### CountDownLatch

```java
public class CountDownLatch {

	// count 값을 멤버 변수에 저장
	public CountDownLatch(int count) { }

  // count 값이 0이 될 때까지 대기
	public void await() throws InterruptedException { }

	// count 값이 0이 될 때까지 대기하되 시간제한을 두고, 대기 성공 여부를 반환
	public boolean await(long timeout, TimeUnit unit) { }

	// count 값을 1 감소
	public void countDown() { }

}
```

- latch는 걸쇠를 의미
- 하나 이상의 스레드가 다른 스레드의 작업이 끝날 때까지 기다리도록 하기 위해 사용
- 생성 시 `몇 개의 동작을 동시에 수행할지`를 정하는 `동시성 수준(concurrency)`을 인자로 받음
- `countDown`, `await` 이라는 메서드를 통해 스레드 접근을 제어
    - countDown: count 값을 1 감소시킴
    - await: count 값이 0이 될 때까지 대기

## 레거시 - wait & notify

- 새로 작성되는 코드는 이 방식을 사용하면 안 됨
    - 동시성 유틸리티가 더 가독성 및 성능이 뛰어남
- 하지만 불가피하게 레거시 코드를 다뤄야 할 수도 있음
- 이 경우 반드시 wait는 `wait의 대기 종료 조건을 조건으로 하는 while 문` 내에서 사용해야 함\

### 예제 코드

```java
synchronized (obj) {
	while (<wait의 탈출 조건>)
		obj.wait();

	// 조건이 충족되고 notify가 호출된 경우의 동작 수행
}
```

- 대기 전에 조건을 검사하는 이유는 `응답 불가 상태 예방`을 위함
    - 탈출 조건을 이미 만족하고 notify가 호출된 이후인데 wait가 호출되면 해당 스레드는 언제 깨어날지(혹은 영영 깨어나지 않을지) 알 수 없는 상태가 됨
- 대기 후에 조건을 검사하는 이유는 `안전 실패를 막기` 위함
    - 조건이 만족되지 않았는데 스레드가 깨어날 수 있는 다양한 상황이 존재
    - 이 경우 탈출 조건이 만족되었는지 확인하고 그렇지 않다면 다시 스레드를 잠재우기 위한 조치
- 항상 notify 대신 notifyAll을 사용하는 편이 좋음
    - 일단 모든 스레드를 깨우고 각 스레드가 탈출 조건을 만족했는지 확인하고 다시 잠들거나 말거나 선택하도록 하는 편이 안전하기 때문
    - notify를 사용했다가 깨어나야 할 스레드가 깨어나지 않는 쪽이 더 위험한 상황

## 정리

- 동시성 프레임워크=고레벨언어, wait&notify=어셈블리어 정도로 비유할 수 있음
- 하지만 부득이하게 레거시 코드를 다루다가 wait&notify를 사용해야 한다면 아래의 조건을 반드시 준수할 것
    1. wait는 탈출 조건을 명시한 while 문 내에서만 호출
    2. notify 보다는 notifyAll을 사용
