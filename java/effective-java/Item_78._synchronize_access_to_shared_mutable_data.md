# Item78. 공유 중인 가변 데이터는 동기화해 사용하라

## 동기화

### 배타적 실행

- 하나의 가변 데이터를 한 스레드가 변경 중일 때 다른 스레드가 `보지 못하게` 만듦
- 객체는 하나의 일관된 상태에서 다른 일관된 상태로 변환
- 어떤 메서드도 이 객체가 일관되지 않은 상태로 있는 순간을 볼 수 없음

### 스레드 사이의 안정적 통신

- 동기화를 사용하지 않으면 한 스레드가 데이터를 수정했을 때 다른 스레드에서 이 사실을 확인하지 못할 수 있음
    - JVM 최적화 기법에 의해 이와 같이 의도하지 않고 짠 코드도 이렇게 동작할 수 있음
- 즉, 동기화를 통해 한 스레드에서 업데이트한 객체의 최신 상태를 다른 스레드가 인지할 수 있도록 할 수 있음
- 동기화 비용조차 부담이 되는 상황이라면, 배타적 수행은 보장하지 않지만 스레드 간 안정적 통신은 보장하는 `volatile` 한정자를 사용할 수 있음
    - 하지만 객체가 한 번에 하나의 스레드만 사용함이 보장되지 않으면 이 한정자를 사용하는 것은 위험한 선택
- `synchronized` 한정자를 붙이면 배타적 실행, 안정적 통신이 모두 보장됨
    - 메서드 단위로 부여하며, getter/setter에 모두 붙여야 하나의 필드의 동시성 관리가 가능

### Atomic Class

- `java.util.concurrent.atomic` 패키지 내에서 지원되는 primitive type의 wrapper 클래스들
- 기존 동기화 방법보다 더 좋은 성능으로 동기화가 가능하며, 락 없이 스레드 안정성 보장이 가능

## 가장 좋은 방법은 구조적으로 데이터를 분리하는 것

- 결국 동시성을 보장하기보다는 애초에 가변 데이터에 여러 스레드가 접근하지 않도록 구조를 설계하는 것이 가장 좋음
    - 가변 데이터가 스레드 안정성을 보장하게 만듦으로서 동기화를 하지 않았다면 이를 반드시 문서에 남겨 유지보수 과정에서도 이 정책이 계속 지켜지도록 해야 함
- 외부 프레임워크, 라이브러리를 사용할 때에도 다중 스레드 접근에 의해 문제가 생기는 부분이 없는지 잘 파악하고 있어야 함

## 불변과 안전 발행

- 한번 초기화된 이후 다시는 수정할 일이 없어 여러 스레드에서 동시에 접근해도 문제가 없는 객체를 불변(immutable) 객체라고 함
- 불변 객체를 다른 스레드에 건네는 행위를 안전 발행(safe publication)이라고 함

### 객체를 안전 발행하는 방법

1. 클래스 초기화 과정에서 static, volatile, final 등의 방법을 이용
2. 객체를 동시성 컬렉션에 저장
