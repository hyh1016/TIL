# Item 42. 익명 클래스보다는 람다를 사용하라

## 람다 이전의 함수 타입 표현

- Java 8의 람다가 도입되기 이전에는, 메서드에 `특정 행위를 수행하는 함수 타입`을 넘기기 위해 `인터페이스`를 사용
- 실제 argument로 넘기는 것은 `이 인터페이스를 구현한 익명 클래스`

### 예시 - `비교 가능`이라는 성질을 나타내는 함수형 인터페이스 `Comparable`

```java
public interface Comparable<T> {
    public int compareTo(T o);
}
```

```java
public static void main(String[] args) {
    Collections.sort(list, new Comparator<String>() {
        @Override
        public int compare(String s1, String s2) {
            return String.CASE_INSENSITIVE_ORDER.compare(s1, s2);
        }
    });
}
```

## 람다 도입 이후의 함수 타입 표현

- 위의 `Comparable` 같은 인터페이스를 `함수형 인터페이스`라고 함
    - 함수형 인터페이스란, 단 하나의 메서드만을 갖는 인터페이스
- 이 함수형 인터페이스는 Java 8 이후로 람다 방식으로 대체 가능

### 예시 - Comparable 예시 람다로 대체

```java
public static void main(String[] args) {
    Collections.sort(list, (s1, s2) -> String.CASE_INSENSITIVE_ORDER.compare(s1, s2));
}
```

- 이 때 매개변수의 타입은 컴파일러가 context에 따라 추론
    - 추론에 실패하는 경우 컴파일 오류를 발생시키고, 이 때에는 개발자가 명시해줘야 함

## 람다를 사용하지 말아야 할 때

아래의 경우를 제외한 경우에는 함수형 인터페이스를 람다로 대체하는 것이 좋음

### 람다의 동작(코드)이 길어질 때

- 람다는 이름이 없으며(익명), 문서화할 수 없음
- 따라서 하나의 람다 내에서 코드 줄 수가 많아지면 오히려 가독성을 저하시킬 수 있음
    - 최대 세 줄 안에 끝내고, 불가능하다면 람다를 사용하지 않는 쪽을 고려해야 함

### 추상 클래스의 인스턴스를 인자로 넘기려고 할 때

- 람다는 `함수형 인터페이스`만 대체할 수 있음
- 따라서 추상 클래스의 추상 메서드를 구현해 인자로 넘기려고 할 때나, 메서드가 여러 개인 인터페이스/추상 클래스의 구현체를 넘겨야 할 때에는 익명 클래스를 사용해야 함

### this가 자기 자신을 참조해야 할 때

- 람다 함수의 this는 익명 클래스의 바깥 인스턴스를 가리킴
    - 람다는 함수로 취급되기 때문
- 익명 클래스의 this는 익명 클래스 자신을 가리킴
    - 익명 클래스는 클래스로 취급되기 때문
- 따라서, this를 통해 자기 자신의 참조를 이용해야 하는 코드인 경우에도 익명 클래스를 사용해야 함

### 직렬화해야 하는 함수 객체인 경우

- 람다의 직렬화 형태는 구현별(ex: 가상머신별)로 다를 수 있음
- 따라서, 직렬화해야 한다면 반드시 람다 대신 클래스의 인스턴스를 사용해야 함
