# Item 29. 이왕이면 제네릭 타입으로(클래스로) 만들라

## 꺼낸 객체를 형변환하기보다는 제네릭 클래스로 선언

### 제네릭 클래스

- 클래스명 옆에 타입 매개변수를 명시하면 제네릭 클래스를 만들 수 있음
- 주의할 점은, 제네릭은 실체화가 불가하기 때문에 타입으로 사용할 수 있으나 인스턴스를 생성할 수 없음
    - `E[] elements;` 가능
    - `E[] elements = new E[DEFAULT_SIZE];` 불가능
        - E가 어떤 타입인지 생성 시점(런타임)에 알 수 없기 때문

### 제네릭의 실체화 불가를 우회하는 방법 - 비검사 형변환

- `타입 매개변수로 명시적 형변환`을 하여 해당 타입의 인스턴스를 획득하는 방법
    
    ```java
    E[] elements = (E[]) new Object[DEFAULT_SIZE];
    ```
    
    - 해당 필드에 클래스 내부에서만 접근(private)하며, 클라이언트에 반환되거나 다른 메서드에 전달하는 일이 하나도 없다고 보장할 수 있다면 위와 같은 방식으로 획득이 가능
- 배열의 경우 필드의 타입을 형변환하여 획득할 수도 있음
    
    ```java
    E element = (E) elements[index];
    ```
    
    - 배열 전체를 형변환하는 방식이 더 코드도 짧고 형변환을 한 번만 해줘도 되기 때문에 더 선호됨
    - 하지만 컴파일 타임/런타임 타입이 불일치하는 힙 오염(heap pollution)을 유발하기 때문에, 이를 피하고 싶다면 필드 자체를 형변환하는 방식을 사용해야 함

## 한정적 타입 매개변수를 통해 가능한 타입에 제한을 둘 수도 있음

```java
MyClass<E extend Super>
```

- Super 또는 Super를 상속하는 클래스만 타입 매개변수로 사용될 수 있음
- 이 경우의 장점은 E를 사용할 때 Super의 기능을 사용할 수 있다는 것
    - Super가 할 수 있는 일을 E가 할 수 있음이 보장되기 때문
