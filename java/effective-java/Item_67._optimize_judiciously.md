# Item 67. 최적화는 신중히 하라

## 견고함 > 성능

- 성능을 위해 무리하게 최적화를 해서 가독성을 저하시키고 수정하기 어렵도록 견고한 구조를 해치는 것은 좋지 못한 일
- **빠른 프로그램보다는 좋은 프로그램을 작성**
- 성능 문제를 아예 무시하라는 것이 아님. 성능 개선을 하겠다고 완성된 (고품질의) 설계의 기본 틀을 변경하려고 하면 오히려 유지보수가 어려운 꼬인 구조의 시스템이 만들어질 수 있다는 의미
    - 즉, 단지 성능 때문에 설계를 뒤엎는 짓을 하지 말라는 의미
- 가장 좋은 것은 `설계 단계에서부터 성능을 염두해 두는 것`

## 설계 단계에서 성능을 고려하는 방법

### 성능을 제한하는 설계를 피할 것

- 설계가 완성된 후 가장 변경하기 어려운 것은 `컴포넌트 간, 컴포넌트와 외부 시스템 간 소통 방식`
    - API, 네트워크 프로토콜, (영구 저장용) 데이터 포맷 등
- 따라서 이것들 자체에 대한 성능은 미리 염두에 두어야 함 (추후 변경이 어렵기 때문)

### API를 설계할 때 성능 영향 고려

- 정확히는 성능을 제한하도록 짜여진 부분이 없는지를 잘 검토
- 가변 public 타입 - 외부에서 내부 데이터를 변경할 수 있으므로 불필요한 `방어적 복사`를 유발
    - 방어적 복사란? 객체를 반환할 때 같은 객체가 아닌 새 객체를 생성해서 반환하는 것
        - 보통 `인자로 넘어온 객체` 또는 `getter에 의해 반환되어야 하는 객체`가 가변이라 내부 값이 의도치 않게 변경됨을 예방해야 할 때 이 방식을 사용
- 컴포지션 대신 상속을 사용 - 상위 클래스에 종속되어 상위 클래스의 성능 제약까지 물려받음
- 인터페이스 대신 구현체를 타입으로 사용 - 변수가 특정 구현체에 종속되게 하여 더 좋은 구현체가 나오더라도 이용하기 어려워짐

### 성능을 위해 API를 왜곡하지 말 것

- 성능 이슈는 작은 개선을 통해 해결할 수 있을 수 있음
- 하지만 API는 변경이 어려운 부분임
    - 이 API를 사용하는 사람들을 위해 다음 버전 SW를 낸다 해도 계속 하위 호환을 위해 지원해줘야 하기 때문
- 따라서, 성능을 위해 API를 의도적으로 비틀기 보다는 성능 이슈를 추후에 개선하는 편이 좋음

### 최적화를 꼭 해야겠다면, 최적화 시도 전후로 성능을 측정할 것

- 시도한 최적화가 반드시 성능을 개선한다는 보장이 없기 때문
- 측정 결과 변경/가독성 저하에 비해 성능 개선이 미미하거나, 오히려 더 성능이 나빠졌을 수도 있음
    - 프로그램 내에서 성능 이슈가 어디에 있는지 추측하는 것이 어려운 일이기 때문
    - 성능 저하 원인을 쉽게 측정하려면 `프로파일링 도구`를 사용하면 좋음
        - 개별 메서드의 소요 시간, 호출 횟수 등과 같은 런타임 정보를 얻을 수 있는 도구
- Java는 저레벨 언어(C, C++ 등)에 비해 추상화 수준이 높기 때문에, 성능 변화를 예측하기 더 어렵고 성능 변화를 예측하는 일이 더 중요

## 시스템 설계 시 성능을 고려하는 순서

1. 변경이 어려운 부분(API, 네트워크 프로토콜, 영구 저장용 데이터 포맷 등)을 설계할 때에는 성능을 고려
2. 시스템 구현을 완료한 후 성능을 측정
3. 성능 이슈가 존재한다면 프로파일링 도구를 통해 문제의 원인이 되는 지점을 탐색
4. 원인 지점에 대한 최적화 (사용 알고리즘 변경 등)
5. 만족할 때까지 3~4번을 반복하고, 최종 변경 버전에 대해서도 성능을 측정
