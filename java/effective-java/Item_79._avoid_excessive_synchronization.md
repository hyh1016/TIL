# Item 79. 과도한 동기화는 피해라

## 과도한 동기화

- 과도한 동기화는 다음과 같은 문제점을 야기
    1. 예측할 수 없는 동작 (의도하지 않은 예외를 던지거나, 교착상태에 빠짐)
    2. 성능 저하
- 따라서, 동기화는 반드시 필요한(여러 스레드에서 가변 데이터를 제어하는) 상황에서만 사용해야 하며, 동기화 영역 안에서의 작업도 최소한으로 줄여야 함

### 예측할 수 없는 동작

```java
public void addActivity(BiConsumer<List<String>, String> activity) {
    synchronized(list) {
        list.add(activity);
    }
}
```

- 사용자가 정의(구현)한 함수형 인터페이스를 인자로 받아 리스트에 추가하는 메서드
- 사용자가 `list에서 자기 자신을 제거하는 동작을 수행한다면?`
    - 런타임에 예외가 발생할 수 있음
- 사용자가 `list의 제어권을 획득하려는 동작을 수행한다면?`
    - 런타임에 Deadlock(교착상태)이 발생할 수 있음
- 사용자가 호출한 동작이 끝나지 않는다면 - 동기화 영역 내에서 하나의 동작이 오래 수행되면, 그동안 다른 스레드는 보호된 자원을 사용하지 못하고 대기해야 함 (성능 매우 저하)

### 성능 저하

- 동기화 비용 자체가 큰 것은 아님
    - 지속적인 개선으로 무시 가능할 수준이 되었음
- 성능 저하 요인은 아래 두 가지
    1. 스레드 간 경쟁
        - 한 스레드가 자원을 선점하는 동안 다른 스레드는 대기해야 함
    2. 가상머신의 코드 최적화를 제한

## 가변 클래스를 작성하는 방법

1. 동기화를 하지 않고, 클라이언트에게 동기화 책임을 위임
    - ex) java.util
2. 동기화를 내부에서 수행하여 제공
    1. ex) java.util.concurrent
        - 동기화를 보장하는 기능/자료구조 등을 제공하는 라이브러리
- 2번의 경우 사용자가 단일 스레드에서 사용하는 경우에도 불필요한 동기화가 이루어지기 때문에, 1번을 권장
    - StringBuffer의 성능 문제로 뒤늦게 StringBuilder가 등장한 이유이기도 함
- 여러 스레드가 호출하는 메서드 내에서 정적 필드 값을 수정한다면, 이 필드를 사용하기 전에 동기화해야 함
    - 이 정적 필드는 여러 스레드가 동시에 읽거나 수정할 수 있다는 점에서 사실상 전역 변수와 동일하기 때문에 동기화가 이루어져야 함
