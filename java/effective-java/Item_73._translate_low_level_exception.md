# Item 73. 추상화 수준에 맞는 예외를 던지라

## 예외 번역

### 저수준(Low-Level) 예외를 그대로 전파하는 것의 문제점

- API 기준에서, 호출자가 의도한 동작과 관련도 없는 저수준 예외를 받으면 예외의 발생 원인 추적을 어렵게 함
- 또한, API의 내부 구현과 엮여 있어 내부 구현 변경에 의해 다른 예외가 던져질 수 있으며 이 경우 사용하는 클라이언트 측에도 구현 변경이 필요해질 수 있음
- 이 경우 `상위 계층에서 저수준 예외를 잡아 고수준(High-Level) 예외로 변환하여 다시 던지는 예외 번역`을 이용할 수 있음

### 예시

```java
public E get(int index) {
	ListIterator<E> i = listIterator(index);
	try {
		return i.next();
	} catch (NoSuchElementException e) {
		throw new IndexOutOfBoundsException("인덱스: " + index);
	}
}
```

- 위와 같이 인덱스에 해당하는 데이터를 리스트에서 꺼내 반환하는 메서드가 존재
- 내부 구현에서 Iterator를 이용하고 있다면, 리스트 사이즈보다 큰 인덱스가 인자로 들어왔을 때 next()를 호출하는 시점에 `NoSuchElementException` 예외가 발생
- 사용자는 이 예외를 받으면 무슨 요소가 없다는 건지 혼란스러울 수 있음
- 또한, 던져지는 예외는 내부 구현이 Iterator가 아닌 다른 방식으로 변경되면 다른 예외가 될 수 있음
- 이러한 문제를 해결하고 `내부 구현과 관계 없이`, `사용자가 쉽게 이해할 수 있도록` 예외를 변경해 던지는 것

### 예외 번역을 남용하지 말 것

- 저수준 예외를 그대로 던지는 것보다 좋은 방법임은 분명하지만, 코드 가독성을 저하시키고 구현 복잡도를 증가시키는 등의 문제가 있을 수 있음
- 가장 좋은 해결법은 `저수준 메서드가 반드시 성공하도록 하는 것`
- 이를 위해 다음을 시도할 수 있음
    1. 상위 계층에서 미리 인자값을 검사하여 하위 계층에서 예외가 발생하지 않도록 하기
    2. 상위 계층에서 예외를 조용히 쓱싹하여 API 호출자에게까지 전파하지 않기
        - 이 경우 클라이언트에게 문제를 전파하지는 않지만, 적절한 로깅 등을 통해 예외를 인지하고 분석하여 조치를 취할 수 있도록 하는 것이 좋음
