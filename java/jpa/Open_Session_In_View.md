# OSIV (Open Session In View)

## 영속성 컨텍스트의 유효 범위

- 트랜잭션 범위 == 영속성 컨텍스트의 범위라고 생각하기 쉽지만 **아님**
- 기본 설정으로는 영속성 컨텍스트의 유효 범위는 트랜잭션 단위가 아닌 **요청 단위**
- 이는 스프링 프레임워크의 OSIV(Open Session In View) 설정 때문
    - 요청이 들어오면 컨트롤러에 도달하기 전 미리 영속성 컨텍스트를 생성해두고(필터, 인터셉터와 같은 사전 전역 처리 주체가 수행) 트랜잭션은 이를 가져다 씀

## 왜 OSIV가 기본적으로 활성화되어 있을까?

- 트랜잭션이 종료된 후 영속성 컨텍스트를 제거하게 되면 presentation layer에서 필요한 데이터를 read하는 과정에서 지연 로딩이 불가능해 문제가 생길 수 있음
- 즉, presentation layer에서도 엔티티를 영속 상태로 유지해 지연 로딩을 통해 특정 데이터들은 뷰에서 요구할 때에만 세팅하기 위해 OSIV는 기본적으로 활성화되어 있음

### 초기의 OSIV

- **요청 당 트랜잭션**
- 문제는, presentation layer에서 제공할 데이터의 일시적 변경을 위해 엔티티의 상태를 변경하게 되면 dirty checking에 의해 데이터 자체의 상태가 변경될 수도 있는 문제가 있음

### Spring OSIV

- 요청 당 트랜잭션 방식의 문제점 해결을 위해 트랜잭션은 비즈니스 계층으로 유지하고 영속성 컨텍스트의 유효 범위만 요청 전반으로 확장함
- 이를 통해 컨트롤러에서 데이터를 수정하게 되어도 이 수정을 커밋하지 않으므로 변경이 실제 DB에까지 영향을 미치지 않게 됨

## Open Session In View의 위험성

### 너무 긴 DB 커넥션 점유

- 실제로는 트랜잭션 범위 내에서만 DB 접근이 일어나므로 그 후에는 커넥션을 반환해도 되지만, OSIV를 사용하면 요청 전반에서 DB 커넥션을 점유
- 트래픽이 몰린다면, 커넥션 고갈로 인한 장애가 발생할 수 있음

### 트랜잭션 밖에서 영속성 컨텍스트 내 데이터에 접근할 수 있음

- 물론 뷰 계층 등에서 **트랜잭션 없이 DB 데이터를 수정하는 동작**이 벌어지면 **절대 안 되므로** 이러한 접근이 일어난다면 예외가 발생하고 실제 반영은 이루어지지 않도록 조치가 취해져 있음
- 하지만 트랜잭션 없이 READ는 가능하며, Lazy Loading 또한 가능하기 때문에 의도치 않은 추가 쿼리가 발생할 위험성은 있음

## 언제 사용?

- 유의할 점은, OSIV 사용 여부는 `기본적으로 true`
    - `spring.jpa.open-in-view` 프로퍼티에 의해 제어되며 기본값은 true
    - 이 값을 false로 설정해주면 OSIV를 사용하지 않게 되며 트랜잭션 범위 내에서만 영속성 컨텍스트가 유효하게 됨
- 사용자가 많아 DB 커넥션이 고갈될 여지가 있는 서비스에서는 OSIV를 사용하지 않는 것이 좋음
    - 대신, 이렇게 한다면 트랜잭션 범위 밖에서 Lazy Loading이 일어나지 않도록 주의해야 함
        - 만약 발생한다면 `LazyInitializationException` 이 발생하게 되므로
    - 또한, 하나의 요청 처리에서 너무 많은 트랜잭션에서 엔티티를 중복 조회하여 여러 번 쿼리가 날아가지 않도록 로직을 주의해서 작성해야 함
- 하지만 최근에는 presentation layer에서 아예 해당 계층을 위한 별도 dto를 정의해 사용하는 경우가 많으므로 해당 옵션을 사용할 일이 잘 없음