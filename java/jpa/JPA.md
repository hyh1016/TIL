# JPA

## ORM (객체-관계 매핑)

- 객체와 관계형 데이터베이스 간에는 **패러다임 불일치** 문제가 존재
- ORM을 사용하기 이전에는 개발자가 직접 이 패러다임 불일치를 해결하기 위한 코드를 작성해 옴
    - 그러나 이러한 코드는 중복이 많고, 변경에 취약함 ⇒ 유지보수 용이성이 떨어짐
- ORM은 이 패러다임 불일치 문제를 해결해주는 프레임워크
- 개발자가 객체지향 애플리케이션을 개발할 때 관계형 데이터베이스의 패러다임으로부터 관심을 분리하고 애플리케이션의 핵심 로직에만 집중할 수 있도록 해줌

## JPA

- 자바 진영의 ORM 기술에 대한 표준 명세
- 자바에서 가장 대중적인 ORM 프레임워크인 `Hibernate`를 기반으로 만들어짐
    - 즉, 출시 순서는 Hibernate가 JPA보다 앞임
- JPA는 “인터페이스”
    - 다른 구현체로 바꾸기 용이함
    - 하지만 현재로서는 Hibernate 특화 기능이 너무 많이 사용되고 있어서 과연…?
        - 데이터베이스 방언(dialect) 설정이라든지
- Mybatis와 같은 SQL Mapper와의 차이?
    - SQL Mapper는 개발자가 SQL 코드를 작성하면 이걸 기반으로 JDBC API를 이용해 응답을 얻고 이를 객체로 매핑
    - 개발자가 직접 SQL을 작성해야 하기 때문에 패러다임 불일치는 여전함

## JPQL

- JPA에서 사용하는 SQL을 한 단계 추상화한 쿼리 언어
- JPQL은 그 구조가 SQL과 닮았지만 **데이터베이스에 어떤 테이블들이 있는지** 전혀 모름
- JPQL을 구성하는 것들은 객체, 객체의 필드값
- SQL의 추상화 언어이기 때문에, 특정 데이터베이스에 의존하지 않음. DB를 변경해도 JPQL 변경은 불필요함
    - 대신 Dialect를 변경해주면 됨

### 특징

- select, update, delete 가능
- insert는 entity manager의 persist를 이용하면 됨
- select JPQL은 영속성 컨텍스트의 관리 하에 수행됨
- update, delete JPQL은 영속성 컨텍스트의 관리를 받지 않음
    - 쓰기 지연 X
    - 엔티티와의 불일치 예방을 위해 flush가 자동으로 호출됨
