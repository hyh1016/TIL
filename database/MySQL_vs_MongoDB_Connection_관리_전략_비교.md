# MySQL vs MongoDB, 커넥션 관리 전략 비교

## MySQL

### 특징

- 커넥션이 고비용 (Thread per Connection)
- 커넥션을 맺고 끊는 비용이 큼
    - 왜? 커넥션의 Context에 많은 데이터를 저장하기 때문
- Thread per Connection이기 때문에 커넥션이 너무 많아지면 Context Switching 비용도 커짐 (CPU 활용 효율 저하)
- 클라이언트에서 하나의 address로 연결
- 커넥션이 고비용인 만큼 커넥션을 재사용하는 것이 필수적이고, Driver에서 기본적으로 connection pooling을 하지 않기 때문에 HikariCP 같은 커넥션 풀을 사용해 클라이언트(애플리케이션) 측에서 커넥션을 잘 관리해야 함
- 커넥션을 한꺼번에 너무 많이 만들면 CPU 사용량이 갑자기 급증할 수도 있음
    - 왜? Disk IOPS는 정해져 있기 때문에 어차피 일부 커넥션의 쿼리만 처리되고 나머지는 대기하게 됨. 대기 커넥션이 많아지면 CPU의 Context Switching이 잦아지며 사용량이 급증

### 궁금한 점

- 왜 MySQL은 driver를 MongoDB driver처럼 스마트하게 만들지 않았을까?
    - RDB와 NoSQL의 설계 철학 차이. RDB는 중앙 집중형(DB는 강력하고 죽지 않는다)이기 때문에, 인프라 레벨(RDB 및 DB 관련 시스템)에서 모든걸 처리하고 클라이언트(및 Driver)의 부담을 덜고자 함
    - 따라서 클라이언트에서 이를 판단하는 대신 차라리 미들웨어(proxy, LB, ...)를 두고 클라이언트와 이 미들웨어를 연결하게 하여 미들웨어~RDB 레벨에서 모든 부가 로직을 처리하고자 함

## MongoDB

### 특징

- 상대적으로 커넥션의 비용이 낮음
    - 하나의 스레드가 여러 커넥션을 처리할 수 있음
    - 실제 쿼리를 수행 중인 커넥션에 스레드가 할당되는 방식 (like virtual thread)
- NoSQL은 설계 원칙 상 주로 분산 데이터베이스, 클러스터 구조임. 그래서 클라이언트에서 연결할 때에도 하나 이상의 address를 명시하여 전체 노드와 연결될 수 있도록 하고, 실제로 커넥션도 전체 노드와 각각 맺음
    - 각 노드의 primary/secondary 여부를 판단하기 위함
    - 클라이언트에서 secondary read 등을 알맞게 처리하기 위함

### 궁금한 점

- 왜 primary/secondary의 판단을 MongoDB에 물어보는 게 아니라 client가 모든 노드에 연결해서 판단하게 만들었을까? (왜 client의 부담을 늘렸을까?)
    - 이 또한 RDB와 NoSQL의 설계 철학 차이. NoSQL은 속도와 유연성을 중시하기 때문에, 미들웨어를 두는 대신 클라이언트가 다이렉트로 처리하게 하여 Hop 수를 줄임으로써 속도를 최적화하고자 함
    - NoSQL의 등장 시기에는 인프라에 대한 완벽한 신뢰가 깨진 것도 있음. 클라이언트 레벨에서 모든 노드의 상태를 체크하면(feat. heartbeat) 인프라에 의한 지연 없이 노드의 상태를 알 수 있음

## 튜닝 가이드

### MySQL

- 커넥션 당 메모리 소모량 약 2~4MB
- 기본 max_connection 값이 작기 때문에 기본 값을 늘려야 하는 경우가 많음
- 연결의 비용이 비싸기 때문에 min/max 커넥션 수를 달리 하는 것보다 똑같이 설정하는 것을 권장
    - 트래픽에 따라 연결을 새로 맺고 끊고 하는 것도 비용 낭비라고 보는 것

### MongoDB

- 커넥션 당 메모리 소모량 약 1MB
- 기본 65536
- 연결의 비용이 싸기 때문에 min/max 커넥션 수를 다르게 가져가는 것을 오히려 권장 (min을 max의 10~20% 정도로)

### 공통

- 커넥션 수가 너무 많아지는 것은 리소스에 부하를 줌
- 부하 테스트를 통해 DB가 버틸 수 있는 커넥션 개수의 임계치를 찾는 것이 중요
- OS 레벨에서의 튜닝도 체크포인트 (ex: 리눅스의 경우 File discriptor 제한에 의해 max connection 수가 제한되기도 함)
